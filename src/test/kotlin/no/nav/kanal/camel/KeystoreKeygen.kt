package no.nav.kanal.camel

import org.bouncycastle.asn1.ASN1ObjectIdentifier
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x509.BasicConstraints
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.jce.provider.BouncyCastleProvider
import java.math.BigInteger
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.Security
import java.security.interfaces.RSAPrivateKey
import java.security.interfaces.RSAPublicKey
import java.time.ZonedDateTime
import java.util.Date
import org.bouncycastle.operator.bc.BcRSAContentSignerBuilder
import org.bouncycastle.operator.DefaultDigestAlgorithmIdentifierFinder
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder
import org.bouncycastle.crypto.util.PrivateKeyFactory
import java.security.cert.X509Certificate

data class X509KeyPair(
        val certificate: X509Certificate,
        val private: RSAPrivateKey,
        val trustChain: Array<X509Certificate>
)

fun generateKeyStore() : KeyStore {
    Security.addProvider(BouncyCastleProvider())
    return KeyStore.getInstance("PKCS12").apply {
        load(null, null)
        val rootPair = generateKeysFor(12345, "Root certificate", "dn=Secure certificates root", this, null, false)
        val intermediatePair = generateKeysFor(123456789, "Intermediate certificate", "dn=Secure certificates intermediate", this, rootPair, false)

        generateKeysFor(984661185, "posten", "dn=Posten test certificate", this, intermediatePair)
        generateKeysFor(889640782, "app-key", "dn=NAV test certificate", this, intermediatePair)

        /*
         This is a workaround used for making the sikker digital post java client work.
         For testing I've pointed the client to the keystore generated by this code. Since the java library checks the
         number of certificates in the truststore to validate if its the right one we need to add a few extra
         certificates and keys, this is not actually needed by the parts we use in sdpkanal
          */
        generateKeysFor(1, "mock1", "dn=NAV test certificate", this, intermediatePair)

        aliases().toList().map { getCertificate(it) }.forEach { println(it) }
    }
}

fun generateKeysFor(
        orgNr: Long,
        alias: String,
        orgName: String,
        keystore: KeyStore,
        signingPair: X509KeyPair?,
        savePrivateKey: Boolean = true
): X509KeyPair {
    val dnString = "$orgName, SERIALNUMBER=$orgNr"
    val keygen = KeyPairGenerator.getInstance("RSA", "BC")
    keygen.initialize(2048)
    val keyPair = keygen.genKeyPair()
    val publicKey = keyPair.public as RSAPublicKey
    val privateKey = keyPair.private as RSAPrivateKey
    val dn = X500Name(dnString)

    val issuerDn = when(signingPair) {
        null -> dn
        else -> X500Name(signingPair.certificate.subjectDN.name)
    }

    val privateKeyAsymKeyParam = PrivateKeyFactory.createKey(when (signingPair) {
        null -> privateKey
        else -> signingPair.private
    }.encoded)

    val validFrom = Date.from(ZonedDateTime.now().minusYears(1).toInstant())
    val validTo = Date.from(ZonedDateTime.now().plusYears(1).toInstant())

    val subjPubKeyInfo = SubjectPublicKeyInfo.getInstance(publicKey.encoded)

    val sigAlgId = DefaultSignatureAlgorithmIdentifierFinder().find("SHA1withRSA")
    val digAlgId = DefaultDigestAlgorithmIdentifierFinder().find(sigAlgId)

    val sigGen = BcRSAContentSignerBuilder(sigAlgId, digAlgId).build(privateKeyAsymKeyParam)

    val certificateHolder = X509v3CertificateBuilder(issuerDn, BigInteger.valueOf(orgNr), validFrom, validTo, dn, subjPubKeyInfo)
            .addExtension(ASN1ObjectIdentifier("2.5.29.19"), true, BasicConstraints(true))
            .build(sigGen)

    val certificate = JcaX509CertificateConverter().setProvider("BC").getCertificate(certificateHolder)

    val trustChain = when(signingPair) {
        null -> arrayOf(certificate)
        else -> arrayOf(certificate, *signingPair.trustChain)
    }

    if (savePrivateKey) {
        keystore.setKeyEntry(alias, privateKey, "changeit".toCharArray(), trustChain)
    } else {
        keystore.setCertificateEntry(alias, certificate)
    }

    return X509KeyPair(certificate, privateKey, trustChain)
}
